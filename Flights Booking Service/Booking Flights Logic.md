# BASIC BOOKING FLIGHTs LOGIC
- [VIDEO](https://drive.google.com/file/d/1xeyCwaqdSSgzaicSLN__ylYWFEaCRyiz/view?usp=drive_link)

# BOOKING FLIGHTs MECHANISM

## Problems:

## 1. Same Seat Selection

## 2. There are two concurrent bookings for one seat
- The Booking Mechanism depends on payments. 
- When u are playing with someone's payments u have to be very careful.
- The same seat has been selected by two users, but neither has started the booking process.
- As soon as both users started the booking process.
- The request which reaches the server first with milli/micro/nano seconds difference gets blocked for 10 mins and block key is sent back. [Dependent on network speed]
- Other requests get block fail response.
- Successful request has 10 mins to book the ticket using the block key.
- We need to complete payment, booking confirmation and user notifications like email and sms with in 10 mins.
- After 10 minutes ticket is released to all if the ticket is not confirmed.

## 3. During the processing of the payment request/response, the payment fails, etc.
- The client tries to make a payment, and the payment went through but while returning the response something went wrong.
- In this type of cases, people do double payment transactions for the same booking.
- Although the transaction is already done u just have not yet received the notification.
- U end up loosing ur money twice.
- By mistake, the users have initiated 2 payment requests for the same booking. 
- 2 payment requests from the same user for the same booking ID should not go parallelly at the same point of time. But one after another they can definitely go.

**To solve this issue there is a concept known as IDEMPOTENCY.**

**IDEMPOTENCY** -> It is a property of certain operations in maths and computer science where they can be applied multiple times without changing the result beyond the first application.
eg.
U made a payment request and the payment has been made, but by mistake, u initiated another(second) payment request. Now the first request has already made the payment so only the first request will be applied and the second request will not be applied and will not show any effect. In case the first request was not successful and failed, then we will definitely try to apply for the second request.

### IDEMPOTENT APIs

When an HTTP method is idempotent in a REST API, this means that if you send multiple identical requests, only the initial request would cause a change. Therefore, the results returned to the user will not depend on how many times the method has been called.

When you make a payment online, you expect it to process without double charging your card. If it does double charge you, this creates a negative customer experience that may push you away from the business forever — costing the company your lifetime value as a customer. 

If you are on the other end of this transaction, building the API to process payments, you can use the API idempotency to prevent issues like this from happening in the first place.

**To make an API idempotent, you have to send an IDEMPOTENCY KEY.** Idempotency keys are unique tokens that you submit as a request header, that guarantee that only one resource will be created regardless of how many times a request is sent to us. If the request fails, then it's perfectly safe to retry as long as you use the same idempotency key.  

**Working of IDEMPOTENCY APIs :**

- Client generates a unique idempotency key: The client includes a unique identifier, often in the form of a [UUID](https://www.npmjs.com/package/uuid) (Universally Unique Identifier), in the request header or body before sending the API request. This key should be generated by the client and should remain consistent for subsequent retries of the same operation.

- Server processes the request: When the server receives the API request, it checks if the idempotency key has been used before. If the key is new, the server processes the request normally. If the key has been used previously, the server recognizes it as a duplicate request and ignores the redundant processing.

- Server stores the idempotency key: Upon processing the request successfully, the server associates the idempotency key with the operation's result or outcome. It may store this association temporarily or persistently, depending on the specific implementation.

- Response handling by the client: The server responds to the client's API request, providing the outcome of the operation. The client can inspect the response to determine whether the request succeeded or failed. If the client receives an error response or does not receive any response within a specified timeout, it can choose to retry the request using the same idempotency key.

- Retries and idempotent behavior: If the client retries the same request with the same idempotency key, the server recognizes it as a duplicate request based on the key and again ignores redundant processing. The server responds with the same outcome as the original request, ensuring that repeating the operation does not cause any unintended side effects.

We can store the IDEMPOTENCY KEYs in the 

- DB 

    - Drawback: Retrieving from DB takes a time

- CACHE DB
    - Redis is an open-source data structure store that is primarily used as a database, message broker, or cache.


- Memory Object

    - Simple implementation
    - Drawback: If the server goes down the object will also go down
    
Learn more about IDEMPOTENT APIs at the following link
- [LINK](https://blog.hubspot.com/website/idempotent-api)



</br>
</br>

# Booking Systems - Race Conditions

**In Booking Systems,  there can be multiple cases of  Race Conditions.**

To handle these kinds of race conditions we can implement 2 different kinds of mechanisms. 

- Pessimistic Concurrency Control

- Optimistic Concurrency Control 

In our Booking Flights System we are going to use:

- Optimistic Concurrency Control [Manual Checks]

- Pessimistic Concurrency Control [Serializable Isolation Level]

